 void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
              }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
以上是计算next数组的过程，具体说明一下
当s[j]!=s[i]的时候，可以得出next[i-1] == j   这是必然的
由于我们的next数组（我这里的没有-1操作）记录的是当字符串回退的时候，应该从下标为几的元素开始
这里s[j]!=s[i]  说明在i-1之前，是有对称的（即s[j-1] == s[i-1],以此类推）
所以next[i-1]指向绝对不会是j-1，并且由于我们正常思维，由于之前有对称产生，那么我们应该比较未知的字符，即j-1的下一个字符j
于是我们得到当s[j]!=s[i]的时候，可以得出next[i-1] == j

这里提一下next数组的思想，当找到一对不匹配点的时候，即while (j > 0 && s[i] != s[j])：
  由于之前的字符串有对称，我们要做的就是找已匹配完成的对称字符串中的更小的对称字符串
  所以我们使用next[i-1]来找使得一个对称字符串开始出现不对称的点，或者如果next[i-1] == 0 的时候（此时next[i-1]是对称轴），我们直接将s[j]与s[0]比较即可
  已知next[i-1] == j  并且此时[0,j-1]依然是对称字符串，此时我们找到了一个小一些的对称字符串。以此类推，在寻找小字符串的过程中不断比较s[k]与s[i]如果相等
  就将next[i] = k+1,如果没有找到就一直找下去，知道遇到next[idnex] == 0，此时于s[0]进行比较，若相同，next[j] =1,否则记为0


附一个讲解思路链接，讲的很好https://cloud.tencent.com/developer/article/1706743
  



  
